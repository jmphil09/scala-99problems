package arithmetic {

  class S99Int(val start: Int) {
    import S99Int._

    //P31 (**) Determine whether a given integer number is prime.
    def isPrime: Boolean = {
      def helper(number: Int, counter: Int, limit: Int): Boolean = {
        if (number < 2) false
        else if (counter == limit) true
        else if (number % counter == 0) false
        else helper(number, counter + 1, limit)
      }
      val lim = math.sqrt(start).toInt + 1
      helper(start, 2, lim)
    }

    //P33 (*) Determine whether two positive integer numbers are coprime.
    //Two numbers are coprime if their greatest common divisor equals 1.
    def isCoprimeTo(n: Int): Boolean = {
      gcd(start, n) == 1
    }

    //P34 (**) Calculate Euler's totient function phi(m).
    //Euler's so-called totient function phi(m) is defined as the number of positive integers r (1 <= r <= m) that are coprime to m.
    def totient: Int = {
      def phi(n: Int, counter: Int): Int = {
        if (n > start) counter
        else if (n.isCoprimeTo(start)) phi(n + 1, counter + 1)
        else phi(n + 1, counter)
      }
      phi(1, 0)
    }

    //P35 (**) Determine the prime factors of a given positive integer.
    //Construct a flat list containing the prime factors in ascending order.
    def primeFactors: List[Int] = {
      def buildPrimes(a: Int): List[Int] = {
        if (start.isPrime) List(start)
        else if (a > math.sqrt(start) + 1) List()
        else if (!start.isCoprimeTo(a) && a.isPrime) List(a) ++ (start / a).primeFactors
        else buildPrimes(a + 1)
      }
      buildPrimes(2)
    }

    //P36 (**) Determine the prime factors of a given positive integer (2).
    //Construct a list containing the prime factors and their multiplicity.
    def primeFactorMultiplicity: List[(Int, Int)] = {
      val primelist = start.primeFactors
      def nestingFunction(list: List[Int], pair: (Int, Int), accum: List[(Int, Int)]): List[(Int, Int)] = {
        if (list.isEmpty) accum
        else if (list.tail.isEmpty) accum ++ List(pair)
        else if (list.head == list.tail.head) nestingFunction(list.tail, (pair._1, pair._2 + 1), accum)
        else nestingFunction(list.tail, (list.tail.head, 1), accum ++ List(pair))
      }
      nestingFunction(primelist, (primelist.head, 1), List())
    }
  }

  object S99Int {
    implicit def int2S99Int(i: Int): S99Int = new S99Int(i)

    //P32 (**) Determine the greatest common divisor of two positive integer numbers.
    //Use Euclid's algorithm.
    def gcd(a: Int, b: Int): Int = {
      if (b == 0) a
      else gcd(b, a % b)
    }

    //P37 (**) Calculate Euler's totient function phi(m) (improved).
    def phi(n: Int): Int = {
      def phiHelper(list: List[(Int, Int)]): Int = {
        if (list.isEmpty) 1
        else {
          val p = list.head._1
          val m = list.head._2
          ((p - 1) * Math.pow(p, m - 1).toInt) * phiHelper(list.tail)
        }
      }
      if (n == 0) 0
      else phiHelper(n.primeFactorMultiplicity)
    }

    //P38 (*) Compare the two methods of calculating Euler's totient function.
    //Use the solutions of problems P34 and P37 to compare the algorithms. Try to calculate phi(10090) as an example.
    //Note: This algorithm was obtained from wikipedia.
    def time(f: => Unit) = {
      val s = System.currentTimeMillis
      f
      System.currentTimeMillis - s
    }
    
  //P39 (*) A list of prime numbers.
  //Given a range of integers by its lower and upper limit, construct a list of all prime numbers in that range.
  def listPrimesinRange(r: Range): List[Int] = {
    if (r.isEmpty) Nil
    else if (r.head.isPrime) List(r.head) ++listPrimesinRange(r.tail)
    else listPrimesinRange(r.tail)
  }
  }

} 